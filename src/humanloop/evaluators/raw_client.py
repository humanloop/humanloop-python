# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..requests.chat_message import ChatMessageParams
from ..requests.evaluator_activation_deactivation_request_activate_item import (
    EvaluatorActivationDeactivationRequestActivateItemParams,
)
from ..requests.evaluator_activation_deactivation_request_deactivate_item import (
    EvaluatorActivationDeactivationRequestDeactivateItemParams,
)
from ..types.create_evaluator_log_response import CreateEvaluatorLogResponse
from ..types.evaluator_response import EvaluatorResponse
from ..types.file_environment_response import FileEnvironmentResponse
from ..types.http_validation_error import HttpValidationError
from ..types.list_evaluators import ListEvaluators
from ..types.log_status import LogStatus
from ..types.paginated_data_evaluator_response import PaginatedDataEvaluatorResponse
from ..types.project_sort_by import ProjectSortBy
from ..types.sort_order import SortOrder
from .requests.create_evaluator_log_request_judgment import CreateEvaluatorLogRequestJudgmentParams
from .requests.create_evaluator_log_request_spec import CreateEvaluatorLogRequestSpecParams
from .requests.evaluator_request_spec import EvaluatorRequestSpecParams

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEvaluatorsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def log(
        self,
        *,
        parent_id: str,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        stdout: typing.Optional[str] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        trace_parent_id: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        create_evaluator_log_request_environment: typing.Optional[str] = OMIT,
        save: typing.Optional[bool] = OMIT,
        log_id: typing.Optional[str] = OMIT,
        output_message: typing.Optional[ChatMessageParams] = OMIT,
        judgment: typing.Optional[CreateEvaluatorLogRequestJudgmentParams] = OMIT,
        marked_completed: typing.Optional[bool] = OMIT,
        spec: typing.Optional[CreateEvaluatorLogRequestSpecParams] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateEvaluatorLogResponse]:
        """
        Submit Evaluator judgment for an existing Log.

        Creates a new Log. The evaluated Log will be set as the parent of the created Log.

        Parameters
        ----------
        parent_id : str
            Identifier of the evaluated Log. The newly created Log will have this one set as parent.

        version_id : typing.Optional[str]
            ID of the Evaluator version to log against.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to log to.

        path : typing.Optional[str]
            Path of the Evaluator, including the name. This locates the Evaluator in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Evaluator.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        output : typing.Optional[str]
            Generated output from the LLM. Only populated for LLM Evaluator Logs.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        stdout : typing.Optional[str]
            Captured log and debug statements.

        provider_request : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw request sent to provider. Only populated for LLM Evaluator Logs.

        provider_response : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw response received the provider. Only populated for LLM Evaluator Logs.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        trace_parent_id : typing.Optional[str]
            The ID of the parent Log to nest this Log under in a Trace.

        user : typing.Optional[str]
            End-user ID related to the Log.

        create_evaluator_log_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        log_id : typing.Optional[str]
            This will identify a Log. If you don't provide a Log ID, Humanloop will generate one for you.

        output_message : typing.Optional[ChatMessageParams]
            The message returned by the LLM. Only populated for LLM Evaluator Logs.

        judgment : typing.Optional[CreateEvaluatorLogRequestJudgmentParams]
            Evaluator assessment of the Log.

        marked_completed : typing.Optional[bool]
            Whether the Log has been manually marked as completed by a user.

        spec : typing.Optional[CreateEvaluatorLogRequestSpecParams]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateEvaluatorLogResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluators/log",
            method="POST",
            params={
                "version_id": version_id,
                "environment": environment,
            },
            json={
                "path": path,
                "id": id,
                "start_time": start_time,
                "end_time": end_time,
                "output": output,
                "created_at": created_at,
                "error": error,
                "provider_latency": provider_latency,
                "stdout": stdout,
                "provider_request": provider_request,
                "provider_response": provider_response,
                "inputs": inputs,
                "source": source,
                "metadata": metadata,
                "log_status": log_status,
                "parent_id": parent_id,
                "source_datapoint_id": source_datapoint_id,
                "trace_parent_id": trace_parent_id,
                "user": user,
                "environment": create_evaluator_log_request_environment,
                "save": save,
                "log_id": log_id,
                "output_message": convert_and_respect_annotation_metadata(
                    object_=output_message, annotation=ChatMessageParams, direction="write"
                ),
                "judgment": convert_and_respect_annotation_metadata(
                    object_=judgment, annotation=CreateEvaluatorLogRequestJudgmentParams, direction="write"
                ),
                "marked_completed": marked_completed,
                "spec": convert_and_respect_annotation_metadata(
                    object_=spec, annotation=CreateEvaluatorLogRequestSpecParams, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateEvaluatorLogResponse,
                    construct_type(
                        type_=CreateEvaluatorLogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(
        self,
        *,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        user_filter: typing.Optional[str] = None,
        sort_by: typing.Optional[ProjectSortBy] = None,
        order: typing.Optional[SortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SyncPager[EvaluatorResponse]]:
        """
        Get a list of all Evaluators.

        Parameters
        ----------
        page : typing.Optional[int]
            Page offset for pagination.

        size : typing.Optional[int]
            Page size for pagination. Number of Evaluators to fetch.

        name : typing.Optional[str]
            Case-insensitive filter for Evaluator name.

        user_filter : typing.Optional[str]
            Case-insensitive filter for users in the Evaluator. This filter matches against both email address and name of users.

        sort_by : typing.Optional[ProjectSortBy]
            Field to sort Evaluators by

        order : typing.Optional[SortOrder]
            Direction to sort by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SyncPager[EvaluatorResponse]]
            Successful Response
        """
        page = page if page is not None else 1

        _response = self._client_wrapper.httpx_client.request(
            "evaluators",
            method="GET",
            params={
                "page": page,
                "size": size,
                "name": name,
                "user_filter": user_filter,
                "sort_by": sort_by,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedDataEvaluatorResponse,
                    construct_type(
                        type_=PaginatedDataEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _has_next = True
                _get_next = lambda: self.list(
                    page=page + 1,
                    size=size,
                    name=name,
                    user_filter=user_filter,
                    sort_by=sort_by,
                    order=order,
                    request_options=request_options,
                )
                _items = _parsed_response.records
                return HttpResponse(
                    response=_response, data=SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upsert(
        self,
        *,
        spec: EvaluatorRequestSpecParams,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        version_name: typing.Optional[str] = OMIT,
        version_description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Create an Evaluator or update it with a new version if it already exists.

        Evaluators are identified by the `ID` or their `path`. The spec provided determines the version of the Evaluator.

        You can provide `version_name` and `version_description` to identify and describe your versions.
        Version names must be unique within an Evaluator - attempting to create a version with a name
        that already exists will result in a 409 Conflict error.

        Parameters
        ----------
        spec : EvaluatorRequestSpecParams

        path : typing.Optional[str]
            Path of the Evaluator, including the name. This locates the Evaluator in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Evaluator.

        version_name : typing.Optional[str]
            Unique name for the Evaluator version. Version names must be unique for a given Evaluator.

        version_description : typing.Optional[str]
            Description of the version, e.g., the changes made in this version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "evaluators",
            method="POST",
            json={
                "path": path,
                "id": id,
                "version_name": version_name,
                "version_description": version_description,
                "spec": convert_and_respect_annotation_metadata(
                    object_=spec, annotation=EvaluatorRequestSpecParams, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self,
        id: str,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Retrieve the Evaluator with the given ID.

        By default, the deployed version of the Evaluator is returned. Use the query parameters
        `version_id` or `environment` to target a specific version of the Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        version_id : typing.Optional[str]
            A specific Version ID of the Evaluator to retrieve.

        environment : typing.Optional[str]
            Name of the Environment to retrieve a deployed Version from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}",
            method="GET",
            params={
                "version_id": version_id,
                "environment": environment,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Delete the Evaluator with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def move(
        self,
        id: str,
        *,
        path: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Move the Evaluator to a different path or change the name.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        path : typing.Optional[str]
            Path of the Evaluator including the Evaluator name, which is used as a unique identifier.

        name : typing.Optional[str]
            Name of the Evaluator, which is used as a unique identifier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "path": path,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_versions(
        self,
        id: str,
        *,
        evaluator_aggregates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListEvaluators]:
        """
        Get a list of all the versions of an Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for the Evaluator.

        evaluator_aggregates : typing.Optional[bool]
            Whether to include Evaluator aggregate results for the versions in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListEvaluators]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/versions",
            method="GET",
            params={
                "evaluator_aggregates": evaluator_aggregates,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListEvaluators,
                    construct_type(
                        type_=ListEvaluators,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_evaluator_version(
        self, id: str, version_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete a version of the Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        version_id : str
            Unique identifier for the specific version of the Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/versions/{jsonable_encoder(version_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_evaluator_version(
        self,
        id: str,
        version_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Update the name or description of the Evaluator version.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        version_id : str
            Unique identifier for the specific version of the Evaluator.

        name : typing.Optional[str]
            Name of the version.

        description : typing.Optional[str]
            Description of the version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/versions/{jsonable_encoder(version_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def set_deployment(
        self, id: str, environment_id: str, *, version_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Deploy Evaluator to an Environment.

        Set the deployed version for the specified Environment. This Evaluator
        will be used for calls made to the Evaluator in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        environment_id : str
            Unique identifier for the Environment to deploy the Version to.

        version_id : str
            Unique identifier for the specific version of the Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="POST",
            params={
                "version_id": version_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_deployment(
        self, id: str, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Remove deployed Evaluator from the Environment.

        Remove the deployed version for the specified Environment. This Evaluator
        will no longer be used for calls made to the Evaluator in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        environment_id : str
            Unique identifier for the Environment to remove the deployment from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_environments(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[FileEnvironmentResponse]]:
        """
        List all Environments and their deployed versions for the Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[FileEnvironmentResponse]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/environments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[FileEnvironmentResponse],
                    construct_type(
                        type_=typing.List[FileEnvironmentResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_monitoring(
        self,
        id: str,
        *,
        activate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]] = OMIT,
        deactivate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluatorResponse]:
        """
        Activate and deactivate Evaluators for monitoring the Evaluator.

        An activated Evaluator will automatically be run on all new Logs
        within the Evaluator for monitoring purposes.

        Parameters
        ----------
        id : str

        activate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]]
            Evaluators to activate for Monitoring. These will be automatically run on new Logs.

        deactivate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]]
            Evaluators to deactivate. These will not be run on new Logs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/evaluators",
            method="POST",
            json={
                "activate": convert_and_respect_annotation_metadata(
                    object_=activate,
                    annotation=typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams],
                    direction="write",
                ),
                "deactivate": convert_and_respect_annotation_metadata(
                    object_=deactivate,
                    annotation=typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams],
                    direction="write",
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawEvaluatorsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def log(
        self,
        *,
        parent_id: str,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        stdout: typing.Optional[str] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        trace_parent_id: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        create_evaluator_log_request_environment: typing.Optional[str] = OMIT,
        save: typing.Optional[bool] = OMIT,
        log_id: typing.Optional[str] = OMIT,
        output_message: typing.Optional[ChatMessageParams] = OMIT,
        judgment: typing.Optional[CreateEvaluatorLogRequestJudgmentParams] = OMIT,
        marked_completed: typing.Optional[bool] = OMIT,
        spec: typing.Optional[CreateEvaluatorLogRequestSpecParams] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateEvaluatorLogResponse]:
        """
        Submit Evaluator judgment for an existing Log.

        Creates a new Log. The evaluated Log will be set as the parent of the created Log.

        Parameters
        ----------
        parent_id : str
            Identifier of the evaluated Log. The newly created Log will have this one set as parent.

        version_id : typing.Optional[str]
            ID of the Evaluator version to log against.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to log to.

        path : typing.Optional[str]
            Path of the Evaluator, including the name. This locates the Evaluator in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Evaluator.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        output : typing.Optional[str]
            Generated output from the LLM. Only populated for LLM Evaluator Logs.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        stdout : typing.Optional[str]
            Captured log and debug statements.

        provider_request : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw request sent to provider. Only populated for LLM Evaluator Logs.

        provider_response : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw response received the provider. Only populated for LLM Evaluator Logs.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        trace_parent_id : typing.Optional[str]
            The ID of the parent Log to nest this Log under in a Trace.

        user : typing.Optional[str]
            End-user ID related to the Log.

        create_evaluator_log_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        log_id : typing.Optional[str]
            This will identify a Log. If you don't provide a Log ID, Humanloop will generate one for you.

        output_message : typing.Optional[ChatMessageParams]
            The message returned by the LLM. Only populated for LLM Evaluator Logs.

        judgment : typing.Optional[CreateEvaluatorLogRequestJudgmentParams]
            Evaluator assessment of the Log.

        marked_completed : typing.Optional[bool]
            Whether the Log has been manually marked as completed by a user.

        spec : typing.Optional[CreateEvaluatorLogRequestSpecParams]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateEvaluatorLogResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluators/log",
            method="POST",
            params={
                "version_id": version_id,
                "environment": environment,
            },
            json={
                "path": path,
                "id": id,
                "start_time": start_time,
                "end_time": end_time,
                "output": output,
                "created_at": created_at,
                "error": error,
                "provider_latency": provider_latency,
                "stdout": stdout,
                "provider_request": provider_request,
                "provider_response": provider_response,
                "inputs": inputs,
                "source": source,
                "metadata": metadata,
                "log_status": log_status,
                "parent_id": parent_id,
                "source_datapoint_id": source_datapoint_id,
                "trace_parent_id": trace_parent_id,
                "user": user,
                "environment": create_evaluator_log_request_environment,
                "save": save,
                "log_id": log_id,
                "output_message": convert_and_respect_annotation_metadata(
                    object_=output_message, annotation=ChatMessageParams, direction="write"
                ),
                "judgment": convert_and_respect_annotation_metadata(
                    object_=judgment, annotation=CreateEvaluatorLogRequestJudgmentParams, direction="write"
                ),
                "marked_completed": marked_completed,
                "spec": convert_and_respect_annotation_metadata(
                    object_=spec, annotation=CreateEvaluatorLogRequestSpecParams, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateEvaluatorLogResponse,
                    construct_type(
                        type_=CreateEvaluatorLogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(
        self,
        *,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        user_filter: typing.Optional[str] = None,
        sort_by: typing.Optional[ProjectSortBy] = None,
        order: typing.Optional[SortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AsyncPager[EvaluatorResponse]]:
        """
        Get a list of all Evaluators.

        Parameters
        ----------
        page : typing.Optional[int]
            Page offset for pagination.

        size : typing.Optional[int]
            Page size for pagination. Number of Evaluators to fetch.

        name : typing.Optional[str]
            Case-insensitive filter for Evaluator name.

        user_filter : typing.Optional[str]
            Case-insensitive filter for users in the Evaluator. This filter matches against both email address and name of users.

        sort_by : typing.Optional[ProjectSortBy]
            Field to sort Evaluators by

        order : typing.Optional[SortOrder]
            Direction to sort by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AsyncPager[EvaluatorResponse]]
            Successful Response
        """
        page = page if page is not None else 1

        _response = await self._client_wrapper.httpx_client.request(
            "evaluators",
            method="GET",
            params={
                "page": page,
                "size": size,
                "name": name,
                "user_filter": user_filter,
                "sort_by": sort_by,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedDataEvaluatorResponse,
                    construct_type(
                        type_=PaginatedDataEvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _has_next = True
                _get_next = lambda: self.list(
                    page=page + 1,
                    size=size,
                    name=name,
                    user_filter=user_filter,
                    sort_by=sort_by,
                    order=order,
                    request_options=request_options,
                )
                _items = _parsed_response.records
                return AsyncHttpResponse(
                    response=_response, data=AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upsert(
        self,
        *,
        spec: EvaluatorRequestSpecParams,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        version_name: typing.Optional[str] = OMIT,
        version_description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Create an Evaluator or update it with a new version if it already exists.

        Evaluators are identified by the `ID` or their `path`. The spec provided determines the version of the Evaluator.

        You can provide `version_name` and `version_description` to identify and describe your versions.
        Version names must be unique within an Evaluator - attempting to create a version with a name
        that already exists will result in a 409 Conflict error.

        Parameters
        ----------
        spec : EvaluatorRequestSpecParams

        path : typing.Optional[str]
            Path of the Evaluator, including the name. This locates the Evaluator in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Evaluator.

        version_name : typing.Optional[str]
            Unique name for the Evaluator version. Version names must be unique for a given Evaluator.

        version_description : typing.Optional[str]
            Description of the version, e.g., the changes made in this version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "evaluators",
            method="POST",
            json={
                "path": path,
                "id": id,
                "version_name": version_name,
                "version_description": version_description,
                "spec": convert_and_respect_annotation_metadata(
                    object_=spec, annotation=EvaluatorRequestSpecParams, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self,
        id: str,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Retrieve the Evaluator with the given ID.

        By default, the deployed version of the Evaluator is returned. Use the query parameters
        `version_id` or `environment` to target a specific version of the Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        version_id : typing.Optional[str]
            A specific Version ID of the Evaluator to retrieve.

        environment : typing.Optional[str]
            Name of the Environment to retrieve a deployed Version from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}",
            method="GET",
            params={
                "version_id": version_id,
                "environment": environment,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete the Evaluator with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def move(
        self,
        id: str,
        *,
        path: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Move the Evaluator to a different path or change the name.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        path : typing.Optional[str]
            Path of the Evaluator including the Evaluator name, which is used as a unique identifier.

        name : typing.Optional[str]
            Name of the Evaluator, which is used as a unique identifier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "path": path,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_versions(
        self,
        id: str,
        *,
        evaluator_aggregates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListEvaluators]:
        """
        Get a list of all the versions of an Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for the Evaluator.

        evaluator_aggregates : typing.Optional[bool]
            Whether to include Evaluator aggregate results for the versions in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListEvaluators]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/versions",
            method="GET",
            params={
                "evaluator_aggregates": evaluator_aggregates,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListEvaluators,
                    construct_type(
                        type_=ListEvaluators,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_evaluator_version(
        self, id: str, version_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete a version of the Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        version_id : str
            Unique identifier for the specific version of the Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/versions/{jsonable_encoder(version_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_evaluator_version(
        self,
        id: str,
        version_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Update the name or description of the Evaluator version.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        version_id : str
            Unique identifier for the specific version of the Evaluator.

        name : typing.Optional[str]
            Name of the version.

        description : typing.Optional[str]
            Description of the version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/versions/{jsonable_encoder(version_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def set_deployment(
        self, id: str, environment_id: str, *, version_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Deploy Evaluator to an Environment.

        Set the deployed version for the specified Environment. This Evaluator
        will be used for calls made to the Evaluator in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        environment_id : str
            Unique identifier for the Environment to deploy the Version to.

        version_id : str
            Unique identifier for the specific version of the Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="POST",
            params={
                "version_id": version_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_deployment(
        self, id: str, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Remove deployed Evaluator from the Environment.

        Remove the deployed version for the specified Environment. This Evaluator
        will no longer be used for calls made to the Evaluator in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        environment_id : str
            Unique identifier for the Environment to remove the deployment from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/environments/{jsonable_encoder(environment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_environments(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[FileEnvironmentResponse]]:
        """
        List all Environments and their deployed versions for the Evaluator.

        Parameters
        ----------
        id : str
            Unique identifier for Evaluator.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[FileEnvironmentResponse]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/environments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[FileEnvironmentResponse],
                    construct_type(
                        type_=typing.List[FileEnvironmentResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_monitoring(
        self,
        id: str,
        *,
        activate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]] = OMIT,
        deactivate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluatorResponse]:
        """
        Activate and deactivate Evaluators for monitoring the Evaluator.

        An activated Evaluator will automatically be run on all new Logs
        within the Evaluator for monitoring purposes.

        Parameters
        ----------
        id : str

        activate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]]
            Evaluators to activate for Monitoring. These will be automatically run on new Logs.

        deactivate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]]
            Evaluators to deactivate. These will not be run on new Logs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluatorResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"evaluators/{jsonable_encoder(id)}/evaluators",
            method="POST",
            json={
                "activate": convert_and_respect_annotation_metadata(
                    object_=activate,
                    annotation=typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams],
                    direction="write",
                ),
                "deactivate": convert_and_respect_annotation_metadata(
                    object_=deactivate,
                    annotation=typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams],
                    direction="write",
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluatorResponse,
                    construct_type(
                        type_=EvaluatorResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
