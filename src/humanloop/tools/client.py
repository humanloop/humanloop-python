# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .raw_client import RawToolsClient
from ..requests.tool_kernel_request import ToolKernelRequestParams
import datetime as dt
from ..types.log_status import LogStatus
from ..core.request_options import RequestOptions
from ..types.tool_call_response import ToolCallResponse
from ..types.create_tool_log_response import CreateToolLogResponse
from ..types.log_response import LogResponse
from ..types.project_sort_by import ProjectSortBy
from ..types.sort_order import SortOrder
from ..core.pagination import SyncPager
from ..types.tool_response import ToolResponse
from ..types.paginated_data_tool_response import PaginatedDataToolResponse
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..requests.tool_function import ToolFunctionParams
from ..types.files_tool_type import FilesToolType
from ..types.list_tools import ListTools
from ..types.file_environment_response import FileEnvironmentResponse
from ..requests.evaluator_activation_deactivation_request_activate_item import (
    EvaluatorActivationDeactivationRequestActivateItemParams,
)
from ..requests.evaluator_activation_deactivation_request_deactivate_item import (
    EvaluatorActivationDeactivationRequestDeactivateItemParams,
)
from ..types.file_environment_variable_request import FileEnvironmentVariableRequest
from ..requests.file_environment_variable_request import FileEnvironmentVariableRequestParams
from ..core.client_wrapper import AsyncClientWrapper
from .raw_client import AsyncRawToolsClient
from ..core.pagination import AsyncPager

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ToolsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawToolsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawToolsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawToolsClient
        """
        return self._raw_client

    def call(
        self,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        tool: typing.Optional[ToolKernelRequestParams] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        trace_parent_id: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        tool_call_request_environment: typing.Optional[str] = OMIT,
        save: typing.Optional[bool] = OMIT,
        log_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolCallResponse:
        """
        Call a Tool.

        Calling a Tool with inputs runs the tool's source code and logs the result and metadata to Humanloop.

        You can use query parameters `version_id`, or `environment`, to target
        an existing version of the Tool. Otherwise, the default deployed version will be chosen.

        Instead of targeting an existing version explicitly, you can instead pass in
        Tool details in the request body. In this case, we will check if the details correspond
        to an existing version of the Tool. If they do not, we will create a new version. This is helpful
        in the case where you are storing or deriving your Tool details in code.

        Parameters
        ----------
        version_id : typing.Optional[str]
            A specific Version ID of the Tool to call.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to call.

        path : typing.Optional[str]
            Path of the Tool, including the name. This locates the Tool in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Tool.

        tool : typing.Optional[ToolKernelRequestParams]
            Details of your Tool. A new Tool version will be created if the provided details are new.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        trace_parent_id : typing.Optional[str]
            The ID of the parent Log to nest this Log under in a Trace.

        user : typing.Optional[str]
            End-user ID related to the Log.

        tool_call_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        log_id : typing.Optional[str]
            This will identify a Log. If you don't provide a Log ID, Humanloop will generate one for you.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolCallResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.call()
        """
        response = self._raw_client.call(
            version_id=version_id,
            environment=environment,
            path=path,
            id=id,
            tool=tool,
            inputs=inputs,
            source=source,
            metadata=metadata,
            start_time=start_time,
            end_time=end_time,
            log_status=log_status,
            source_datapoint_id=source_datapoint_id,
            trace_parent_id=trace_parent_id,
            user=user,
            tool_call_request_environment=tool_call_request_environment,
            save=save,
            log_id=log_id,
            request_options=request_options,
        )
        return response.data

    def log(
        self,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        tool: typing.Optional[ToolKernelRequestParams] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        stdout: typing.Optional[str] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        trace_parent_id: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        tool_log_request_environment: typing.Optional[str] = OMIT,
        save: typing.Optional[bool] = OMIT,
        log_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateToolLogResponse:
        """
        Log to a Tool.

        You can use query parameters `version_id`, or `environment`, to target
        an existing version of the Tool. Otherwise the default deployed version will be chosen.

        Instead of targeting an existing version explicitly, you can instead pass in
        Tool details in the request body. In this case, we will check if the details correspond
        to an existing version of the Tool, if not we will create a new version. This is helpful
        in the case where you are storing or deriving your Tool details in code.

        Parameters
        ----------
        version_id : typing.Optional[str]
            A specific Version ID of the Tool to log to.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to log to.

        path : typing.Optional[str]
            Path of the Tool, including the name. This locates the Tool in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Tool.

        tool : typing.Optional[ToolKernelRequestParams]
            Details of your Tool. A new Tool version will be created if the provided details are new.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        output : typing.Optional[str]
            Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        stdout : typing.Optional[str]
            Captured log and debug statements.

        provider_request : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw request sent to provider.

        provider_response : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw response received the provider.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        trace_parent_id : typing.Optional[str]
            The ID of the parent Log to nest this Log under in a Trace.

        user : typing.Optional[str]
            End-user ID related to the Log.

        tool_log_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        log_id : typing.Optional[str]
            This will identify a Log. If you don't provide a Log ID, Humanloop will generate one for you.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateToolLogResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.log(
            path="math-tool",
            tool={
                "function": {
                    "name": "multiply",
                    "description": "Multiply two numbers",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "a": {"type": "number"},
                            "b": {"type": "number"},
                        },
                        "required": ["a", "b"],
                    },
                }
            },
            inputs={"a": 5, "b": 7},
            output="35",
        )
        """
        response = self._raw_client.log(
            version_id=version_id,
            environment=environment,
            path=path,
            id=id,
            tool=tool,
            start_time=start_time,
            end_time=end_time,
            output=output,
            created_at=created_at,
            error=error,
            provider_latency=provider_latency,
            stdout=stdout,
            provider_request=provider_request,
            provider_response=provider_response,
            inputs=inputs,
            source=source,
            metadata=metadata,
            log_status=log_status,
            source_datapoint_id=source_datapoint_id,
            trace_parent_id=trace_parent_id,
            user=user,
            tool_log_request_environment=tool_log_request_environment,
            save=save,
            log_id=log_id,
            request_options=request_options,
        )
        return response.data

    def update(
        self,
        id: str,
        log_id: str,
        *,
        output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        stdout: typing.Optional[str] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LogResponse:
        """
        Update a Log.

        Update the details of a Log with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Prompt.

        log_id : str
            Unique identifier for the Log.

        output : typing.Optional[str]
            Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        stdout : typing.Optional[str]
            Captured log and debug statements.

        provider_request : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw request sent to provider.

        provider_response : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw response received the provider.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LogResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.update(
            id="id",
            log_id="log_id",
        )
        """
        response = self._raw_client.update(
            id,
            log_id,
            output=output,
            created_at=created_at,
            error=error,
            provider_latency=provider_latency,
            stdout=stdout,
            provider_request=provider_request,
            provider_response=provider_response,
            inputs=inputs,
            source=source,
            metadata=metadata,
            start_time=start_time,
            end_time=end_time,
            log_status=log_status,
            request_options=request_options,
        )
        return response.data

    def list(
        self,
        *,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        user_filter: typing.Optional[str] = None,
        sort_by: typing.Optional[ProjectSortBy] = None,
        order: typing.Optional[SortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[ToolResponse]:
        """
        Get a list of all Tools.

        Parameters
        ----------
        page : typing.Optional[int]
            Page offset for pagination.

        size : typing.Optional[int]
            Page size for pagination. Number of Tools to fetch.

        name : typing.Optional[str]
            Case-insensitive filter for Tool name.

        user_filter : typing.Optional[str]
            Case-insensitive filter for users in the Tool. This filter matches against both email address and name of users.

        sort_by : typing.Optional[ProjectSortBy]
            Field to sort Tools by

        order : typing.Optional[SortOrder]
            Direction to sort by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[ToolResponse]
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        response = client.tools.list(
            size=1,
        )
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        page = page if page is not None else 1
        _response = self._raw_client._client_wrapper.httpx_client.request(
            "tools",
            method="GET",
            params={
                "page": page,
                "size": size,
                "name": name,
                "user_filter": user_filter,
                "sort_by": sort_by,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedDataToolResponse,
                    construct_type(
                        type_=PaginatedDataToolResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _has_next = True
                _get_next = lambda: self.list(
                    page=page + 1,
                    size=size,
                    name=name,
                    user_filter=user_filter,
                    sort_by=sort_by,
                    order=order,
                    request_options=request_options,
                )
                _items = _parsed_response.records
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upsert(
        self,
        *,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        function: typing.Optional[ToolFunctionParams] = OMIT,
        source_code: typing.Optional[str] = OMIT,
        setup_values: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        attributes: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tool_type: typing.Optional[FilesToolType] = OMIT,
        version_name: typing.Optional[str] = OMIT,
        version_description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Create a Tool or update it with a new version if it already exists.

        Tools are identified by the `ID` or their `path`. The name, description and parameters determine the versions of the Tool.

        You can provide `version_name` and `version_description` to identify and describe your versions.
        Version names must be unique within a Tool - attempting to create a version with a name
        that already exists will result in a 409 Conflict error.

        Parameters
        ----------
        path : typing.Optional[str]
            Path of the Tool, including the name. This locates the Tool in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Tool.

        function : typing.Optional[ToolFunctionParams]
            Callable function specification of the Tool shown to the model for tool calling.

        source_code : typing.Optional[str]
            Code source of the Tool.

        setup_values : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/

        attributes : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Additional fields to describe the Tool. Helpful to separate Tool versions from each other with details on how they were created or used.

        tool_type : typing.Optional[FilesToolType]
            Type of Tool.

        version_name : typing.Optional[str]
            Unique identifier for this Tool version. Each Tool can only have one version with a given name.

        version_description : typing.Optional[str]
            Description of the Version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.upsert(
            path="math-tool",
            function={
                "name": "multiply",
                "description": "Multiply two numbers",
                "parameters": {
                    "type": "object",
                    "properties": {"a": {"type": "number"}, "b": {"type": "number"}},
                    "required": ["a", "b"],
                },
            },
            version_name="math-tool-v1",
            version_description="Simple math tool that multiplies two numbers",
        )
        """
        response = self._raw_client.upsert(
            path=path,
            id=id,
            function=function,
            source_code=source_code,
            setup_values=setup_values,
            attributes=attributes,
            tool_type=tool_type,
            version_name=version_name,
            version_description=version_description,
            request_options=request_options,
        )
        return response.data

    def get(
        self,
        id: str,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Retrieve the Tool with the given ID.

        By default, the deployed version of the Tool is returned. Use the query parameters
        `version_id` or `environment` to target a specific version of the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : typing.Optional[str]
            A specific Version ID of the Tool to retrieve.

        environment : typing.Optional[str]
            Name of the Environment to retrieve a deployed Version from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.get(
            id="tl_789ghi",
        )
        """
        response = self._raw_client.get(
            id, version_id=version_id, environment=environment, request_options=request_options
        )
        return response.data

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete the Tool with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.delete(
            id="tl_789ghi",
        )
        """
        response = self._raw_client.delete(id, request_options=request_options)
        return response.data

    def move(
        self,
        id: str,
        *,
        path: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Move the Tool to a different path or change the name.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        path : typing.Optional[str]
            Path of the Tool including the Tool name, which is used as a unique identifier.

        name : typing.Optional[str]
            Name of the Tool, which is used as a unique identifier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.move(
            id="tl_789ghi",
            path="new directory/new name",
        )
        """
        response = self._raw_client.move(id, path=path, name=name, request_options=request_options)
        return response.data

    def list_versions(
        self,
        id: str,
        *,
        evaluator_aggregates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListTools:
        """
        Get a list of all the versions of a Tool.

        Parameters
        ----------
        id : str
            Unique identifier for the Tool.

        evaluator_aggregates : typing.Optional[bool]
            Whether to include Evaluator aggregate results for the versions in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListTools
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.list_versions(
            id="tl_789ghi",
        )
        """
        response = self._raw_client.list_versions(
            id, evaluator_aggregates=evaluator_aggregates, request_options=request_options
        )
        return response.data

    def delete_tool_version(
        self, id: str, version_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete a version of the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : str
            Unique identifier for the specific version of the Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.delete_tool_version(
            id="id",
            version_id="version_id",
        )
        """
        response = self._raw_client.delete_tool_version(id, version_id, request_options=request_options)
        return response.data

    def update_tool_version(
        self,
        id: str,
        version_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Update the name or description of the Tool version.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : str
            Unique identifier for the specific version of the Tool.

        name : typing.Optional[str]
            Name of the version.

        description : typing.Optional[str]
            Description of the version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.update_tool_version(
            id="id",
            version_id="version_id",
        )
        """
        response = self._raw_client.update_tool_version(
            id, version_id, name=name, description=description, request_options=request_options
        )
        return response.data

    def set_deployment(
        self, id: str, environment_id: str, *, version_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolResponse:
        """
        Deploy Tool to an Environment.

        Set the deployed version for the specified Environment. This Prompt
        will be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to deploy the Version to.

        version_id : str
            Unique identifier for the specific version of the Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.set_deployment(
            id="tl_789ghi",
            environment_id="staging",
            version_id="tv_012jkl",
        )
        """
        response = self._raw_client.set_deployment(
            id, environment_id, version_id=version_id, request_options=request_options
        )
        return response.data

    def remove_deployment(
        self, id: str, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Remove deployed Tool from the Environment.

        Remove the deployed version for the specified Environment. This Tool
        will no longer be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to remove the deployment from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.remove_deployment(
            id="tl_789ghi",
            environment_id="staging",
        )
        """
        response = self._raw_client.remove_deployment(id, environment_id, request_options=request_options)
        return response.data

    def list_environments(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentResponse]:
        """
        List all Environments and their deployed versions for the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentResponse]
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.list_environments(
            id="tl_789ghi",
        )
        """
        response = self._raw_client.list_environments(id, request_options=request_options)
        return response.data

    def update_monitoring(
        self,
        id: str,
        *,
        activate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]] = OMIT,
        deactivate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Activate and deactivate Evaluators for monitoring the Tool.

        An activated Evaluator will automatically be run on all new Logs
        within the Tool for monitoring purposes.

        Parameters
        ----------
        id : str

        activate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]]
            Evaluators to activate for Monitoring. These will be automatically run on new Logs.

        deactivate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]]
            Evaluators to deactivate. These will not be run on new Logs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.update_monitoring(
            id="tl_789ghi",
            activate=[{"evaluator_version_id": "evv_1abc4308abd"}],
        )
        """
        response = self._raw_client.update_monitoring(
            id, activate=activate, deactivate=deactivate, request_options=request_options
        )
        return response.data

    def get_environment_variables(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentVariableRequest]:
        """
        Parameters
        ----------
        id : str
            Unique identifier for File.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentVariableRequest]
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.get_environment_variables(
            id="id",
        )
        """
        response = self._raw_client.get_environment_variables(id, request_options=request_options)
        return response.data

    def add_environment_variable(
        self,
        id: str,
        *,
        request: typing.Sequence[FileEnvironmentVariableRequestParams],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[FileEnvironmentVariableRequest]:
        """
        Add an environment variable to a Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request : typing.Sequence[FileEnvironmentVariableRequestParams]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentVariableRequest]
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.add_environment_variable(
            id="id",
            request=[{"name": "name", "value": "value"}],
        )
        """
        response = self._raw_client.add_environment_variable(id, request=request, request_options=request_options)
        return response.data

    def delete_environment_variable(
        self, id: str, name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentVariableRequest]:
        """
        Parameters
        ----------
        id : str
            Unique identifier for File.

        name : str
            Name of the Environment Variable to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentVariableRequest]
            Successful Response

        Examples
        --------
        from humanloop import Humanloop

        client = Humanloop(
            api_key="YOUR_API_KEY",
        )
        client.tools.delete_environment_variable(
            id="id",
            name="name",
        )
        """
        response = self._raw_client.delete_environment_variable(id, name, request_options=request_options)
        return response.data


class AsyncToolsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawToolsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawToolsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawToolsClient
        """
        return self._raw_client

    async def call(
        self,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        tool: typing.Optional[ToolKernelRequestParams] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        trace_parent_id: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        tool_call_request_environment: typing.Optional[str] = OMIT,
        save: typing.Optional[bool] = OMIT,
        log_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolCallResponse:
        """
        Call a Tool.

        Calling a Tool with inputs runs the tool's source code and logs the result and metadata to Humanloop.

        You can use query parameters `version_id`, or `environment`, to target
        an existing version of the Tool. Otherwise, the default deployed version will be chosen.

        Instead of targeting an existing version explicitly, you can instead pass in
        Tool details in the request body. In this case, we will check if the details correspond
        to an existing version of the Tool. If they do not, we will create a new version. This is helpful
        in the case where you are storing or deriving your Tool details in code.

        Parameters
        ----------
        version_id : typing.Optional[str]
            A specific Version ID of the Tool to call.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to call.

        path : typing.Optional[str]
            Path of the Tool, including the name. This locates the Tool in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Tool.

        tool : typing.Optional[ToolKernelRequestParams]
            Details of your Tool. A new Tool version will be created if the provided details are new.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        trace_parent_id : typing.Optional[str]
            The ID of the parent Log to nest this Log under in a Trace.

        user : typing.Optional[str]
            End-user ID related to the Log.

        tool_call_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        log_id : typing.Optional[str]
            This will identify a Log. If you don't provide a Log ID, Humanloop will generate one for you.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolCallResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.call()


        asyncio.run(main())
        """
        response = await self._raw_client.call(
            version_id=version_id,
            environment=environment,
            path=path,
            id=id,
            tool=tool,
            inputs=inputs,
            source=source,
            metadata=metadata,
            start_time=start_time,
            end_time=end_time,
            log_status=log_status,
            source_datapoint_id=source_datapoint_id,
            trace_parent_id=trace_parent_id,
            user=user,
            tool_call_request_environment=tool_call_request_environment,
            save=save,
            log_id=log_id,
            request_options=request_options,
        )
        return response.data

    async def log(
        self,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        tool: typing.Optional[ToolKernelRequestParams] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        stdout: typing.Optional[str] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        source_datapoint_id: typing.Optional[str] = OMIT,
        trace_parent_id: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        tool_log_request_environment: typing.Optional[str] = OMIT,
        save: typing.Optional[bool] = OMIT,
        log_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateToolLogResponse:
        """
        Log to a Tool.

        You can use query parameters `version_id`, or `environment`, to target
        an existing version of the Tool. Otherwise the default deployed version will be chosen.

        Instead of targeting an existing version explicitly, you can instead pass in
        Tool details in the request body. In this case, we will check if the details correspond
        to an existing version of the Tool, if not we will create a new version. This is helpful
        in the case where you are storing or deriving your Tool details in code.

        Parameters
        ----------
        version_id : typing.Optional[str]
            A specific Version ID of the Tool to log to.

        environment : typing.Optional[str]
            Name of the Environment identifying a deployed version to log to.

        path : typing.Optional[str]
            Path of the Tool, including the name. This locates the Tool in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Tool.

        tool : typing.Optional[ToolKernelRequestParams]
            Details of your Tool. A new Tool version will be created if the provided details are new.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        output : typing.Optional[str]
            Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        stdout : typing.Optional[str]
            Captured log and debug statements.

        provider_request : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw request sent to provider.

        provider_response : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw response received the provider.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        source_datapoint_id : typing.Optional[str]
            Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.

        trace_parent_id : typing.Optional[str]
            The ID of the parent Log to nest this Log under in a Trace.

        user : typing.Optional[str]
            End-user ID related to the Log.

        tool_log_request_environment : typing.Optional[str]
            The name of the Environment the Log is associated to.

        save : typing.Optional[bool]
            Whether the request/response payloads will be stored on Humanloop.

        log_id : typing.Optional[str]
            This will identify a Log. If you don't provide a Log ID, Humanloop will generate one for you.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateToolLogResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.log(
                path="math-tool",
                tool={
                    "function": {
                        "name": "multiply",
                        "description": "Multiply two numbers",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "a": {"type": "number"},
                                "b": {"type": "number"},
                            },
                            "required": ["a", "b"],
                        },
                    }
                },
                inputs={"a": 5, "b": 7},
                output="35",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.log(
            version_id=version_id,
            environment=environment,
            path=path,
            id=id,
            tool=tool,
            start_time=start_time,
            end_time=end_time,
            output=output,
            created_at=created_at,
            error=error,
            provider_latency=provider_latency,
            stdout=stdout,
            provider_request=provider_request,
            provider_response=provider_response,
            inputs=inputs,
            source=source,
            metadata=metadata,
            log_status=log_status,
            source_datapoint_id=source_datapoint_id,
            trace_parent_id=trace_parent_id,
            user=user,
            tool_log_request_environment=tool_log_request_environment,
            save=save,
            log_id=log_id,
            request_options=request_options,
        )
        return response.data

    async def update(
        self,
        id: str,
        log_id: str,
        *,
        output: typing.Optional[str] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        error: typing.Optional[str] = OMIT,
        provider_latency: typing.Optional[float] = OMIT,
        stdout: typing.Optional[str] = OMIT,
        provider_request: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        provider_response: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        source: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        start_time: typing.Optional[dt.datetime] = OMIT,
        end_time: typing.Optional[dt.datetime] = OMIT,
        log_status: typing.Optional[LogStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LogResponse:
        """
        Update a Log.

        Update the details of a Log with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Prompt.

        log_id : str
            Unique identifier for the Log.

        output : typing.Optional[str]
            Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.

        created_at : typing.Optional[dt.datetime]
            User defined timestamp for when the log was created.

        error : typing.Optional[str]
            Error message if the log is an error.

        provider_latency : typing.Optional[float]
            Duration of the logged event in seconds.

        stdout : typing.Optional[str]
            Captured log and debug statements.

        provider_request : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw request sent to provider.

        provider_response : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Raw response received the provider.

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            The inputs passed to the prompt template.

        source : typing.Optional[str]
            Identifies where the model was called from.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Any additional metadata to record.

        start_time : typing.Optional[dt.datetime]
            When the logged event started.

        end_time : typing.Optional[dt.datetime]
            When the logged event ended.

        log_status : typing.Optional[LogStatus]
            Status of a Log. Set to `incomplete` if you intend to update and eventually complete the Log and want the File's monitoring Evaluators to wait until you mark it as `complete`. If log_status is not provided, observability will pick up the Log as soon as possible. Updating this from specified to unspecified is undefined behavior.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LogResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.update(
                id="id",
                log_id="log_id",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.update(
            id,
            log_id,
            output=output,
            created_at=created_at,
            error=error,
            provider_latency=provider_latency,
            stdout=stdout,
            provider_request=provider_request,
            provider_response=provider_response,
            inputs=inputs,
            source=source,
            metadata=metadata,
            start_time=start_time,
            end_time=end_time,
            log_status=log_status,
            request_options=request_options,
        )
        return response.data

    async def list(
        self,
        *,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        name: typing.Optional[str] = None,
        user_filter: typing.Optional[str] = None,
        sort_by: typing.Optional[ProjectSortBy] = None,
        order: typing.Optional[SortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[ToolResponse]:
        """
        Get a list of all Tools.

        Parameters
        ----------
        page : typing.Optional[int]
            Page offset for pagination.

        size : typing.Optional[int]
            Page size for pagination. Number of Tools to fetch.

        name : typing.Optional[str]
            Case-insensitive filter for Tool name.

        user_filter : typing.Optional[str]
            Case-insensitive filter for users in the Tool. This filter matches against both email address and name of users.

        sort_by : typing.Optional[ProjectSortBy]
            Field to sort Tools by

        order : typing.Optional[SortOrder]
            Direction to sort by.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[ToolResponse]
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            response = await client.tools.list(
                size=1,
            )
            async for item in response:
                yield item
            # alternatively, you can paginate page-by-page
            async for page in response.iter_pages():
                yield page


        asyncio.run(main())
        """
        page = page if page is not None else 1
        _response = await self._raw_client._client_wrapper.httpx_client.request(
            "tools",
            method="GET",
            params={
                "page": page,
                "size": size,
                "name": name,
                "user_filter": user_filter,
                "sort_by": sort_by,
                "order": order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedDataToolResponse,
                    construct_type(
                        type_=PaginatedDataToolResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _has_next = True
                _get_next = lambda: self.list(
                    page=page + 1,
                    size=size,
                    name=name,
                    user_filter=user_filter,
                    sort_by=sort_by,
                    order=order,
                    request_options=request_options,
                )
                _items = _parsed_response.records
                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        construct_type(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upsert(
        self,
        *,
        path: typing.Optional[str] = OMIT,
        id: typing.Optional[str] = OMIT,
        function: typing.Optional[ToolFunctionParams] = OMIT,
        source_code: typing.Optional[str] = OMIT,
        setup_values: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        attributes: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        tool_type: typing.Optional[FilesToolType] = OMIT,
        version_name: typing.Optional[str] = OMIT,
        version_description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Create a Tool or update it with a new version if it already exists.

        Tools are identified by the `ID` or their `path`. The name, description and parameters determine the versions of the Tool.

        You can provide `version_name` and `version_description` to identify and describe your versions.
        Version names must be unique within a Tool - attempting to create a version with a name
        that already exists will result in a 409 Conflict error.

        Parameters
        ----------
        path : typing.Optional[str]
            Path of the Tool, including the name. This locates the Tool in the Humanloop filesystem and is used as as a unique identifier. For example: `folder/name` or just `name`.

        id : typing.Optional[str]
            ID for an existing Tool.

        function : typing.Optional[ToolFunctionParams]
            Callable function specification of the Tool shown to the model for tool calling.

        source_code : typing.Optional[str]
            Code source of the Tool.

        setup_values : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Values needed to setup the Tool, defined in JSON Schema format: https://json-schema.org/

        attributes : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Additional fields to describe the Tool. Helpful to separate Tool versions from each other with details on how they were created or used.

        tool_type : typing.Optional[FilesToolType]
            Type of Tool.

        version_name : typing.Optional[str]
            Unique identifier for this Tool version. Each Tool can only have one version with a given name.

        version_description : typing.Optional[str]
            Description of the Version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.upsert(
                path="math-tool",
                function={
                    "name": "multiply",
                    "description": "Multiply two numbers",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "a": {"type": "number"},
                            "b": {"type": "number"},
                        },
                        "required": ["a", "b"],
                    },
                },
                version_name="math-tool-v1",
                version_description="Simple math tool that multiplies two numbers",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.upsert(
            path=path,
            id=id,
            function=function,
            source_code=source_code,
            setup_values=setup_values,
            attributes=attributes,
            tool_type=tool_type,
            version_name=version_name,
            version_description=version_description,
            request_options=request_options,
        )
        return response.data

    async def get(
        self,
        id: str,
        *,
        version_id: typing.Optional[str] = None,
        environment: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Retrieve the Tool with the given ID.

        By default, the deployed version of the Tool is returned. Use the query parameters
        `version_id` or `environment` to target a specific version of the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : typing.Optional[str]
            A specific Version ID of the Tool to retrieve.

        environment : typing.Optional[str]
            Name of the Environment to retrieve a deployed Version from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.get(
                id="tl_789ghi",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.get(
            id, version_id=version_id, environment=environment, request_options=request_options
        )
        return response.data

    async def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete the Tool with the given ID.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.delete(
                id="tl_789ghi",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.delete(id, request_options=request_options)
        return response.data

    async def move(
        self,
        id: str,
        *,
        path: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Move the Tool to a different path or change the name.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        path : typing.Optional[str]
            Path of the Tool including the Tool name, which is used as a unique identifier.

        name : typing.Optional[str]
            Name of the Tool, which is used as a unique identifier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.move(
                id="tl_789ghi",
                path="new directory/new name",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.move(id, path=path, name=name, request_options=request_options)
        return response.data

    async def list_versions(
        self,
        id: str,
        *,
        evaluator_aggregates: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListTools:
        """
        Get a list of all the versions of a Tool.

        Parameters
        ----------
        id : str
            Unique identifier for the Tool.

        evaluator_aggregates : typing.Optional[bool]
            Whether to include Evaluator aggregate results for the versions in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListTools
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.list_versions(
                id="tl_789ghi",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.list_versions(
            id, evaluator_aggregates=evaluator_aggregates, request_options=request_options
        )
        return response.data

    async def delete_tool_version(
        self, id: str, version_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete a version of the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : str
            Unique identifier for the specific version of the Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.delete_tool_version(
                id="id",
                version_id="version_id",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.delete_tool_version(id, version_id, request_options=request_options)
        return response.data

    async def update_tool_version(
        self,
        id: str,
        version_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Update the name or description of the Tool version.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        version_id : str
            Unique identifier for the specific version of the Tool.

        name : typing.Optional[str]
            Name of the version.

        description : typing.Optional[str]
            Description of the version.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.update_tool_version(
                id="id",
                version_id="version_id",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.update_tool_version(
            id, version_id, name=name, description=description, request_options=request_options
        )
        return response.data

    async def set_deployment(
        self, id: str, environment_id: str, *, version_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolResponse:
        """
        Deploy Tool to an Environment.

        Set the deployed version for the specified Environment. This Prompt
        will be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to deploy the Version to.

        version_id : str
            Unique identifier for the specific version of the Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.set_deployment(
                id="tl_789ghi",
                environment_id="staging",
                version_id="tv_012jkl",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.set_deployment(
            id, environment_id, version_id=version_id, request_options=request_options
        )
        return response.data

    async def remove_deployment(
        self, id: str, environment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Remove deployed Tool from the Environment.

        Remove the deployed version for the specified Environment. This Tool
        will no longer be used for calls made to the Tool in this Environment.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        environment_id : str
            Unique identifier for the Environment to remove the deployment from.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.remove_deployment(
                id="tl_789ghi",
                environment_id="staging",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.remove_deployment(id, environment_id, request_options=request_options)
        return response.data

    async def list_environments(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentResponse]:
        """
        List all Environments and their deployed versions for the Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentResponse]
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.list_environments(
                id="tl_789ghi",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.list_environments(id, request_options=request_options)
        return response.data

    async def update_monitoring(
        self,
        id: str,
        *,
        activate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]] = OMIT,
        deactivate: typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolResponse:
        """
        Activate and deactivate Evaluators for monitoring the Tool.

        An activated Evaluator will automatically be run on all new Logs
        within the Tool for monitoring purposes.

        Parameters
        ----------
        id : str

        activate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestActivateItemParams]]
            Evaluators to activate for Monitoring. These will be automatically run on new Logs.

        deactivate : typing.Optional[typing.Sequence[EvaluatorActivationDeactivationRequestDeactivateItemParams]]
            Evaluators to deactivate. These will not be run on new Logs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.update_monitoring(
                id="tl_789ghi",
                activate=[{"evaluator_version_id": "evv_1abc4308abd"}],
            )


        asyncio.run(main())
        """
        response = await self._raw_client.update_monitoring(
            id, activate=activate, deactivate=deactivate, request_options=request_options
        )
        return response.data

    async def get_environment_variables(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentVariableRequest]:
        """
        Parameters
        ----------
        id : str
            Unique identifier for File.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentVariableRequest]
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.get_environment_variables(
                id="id",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.get_environment_variables(id, request_options=request_options)
        return response.data

    async def add_environment_variable(
        self,
        id: str,
        *,
        request: typing.Sequence[FileEnvironmentVariableRequestParams],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[FileEnvironmentVariableRequest]:
        """
        Add an environment variable to a Tool.

        Parameters
        ----------
        id : str
            Unique identifier for Tool.

        request : typing.Sequence[FileEnvironmentVariableRequestParams]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentVariableRequest]
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.add_environment_variable(
                id="id",
                request=[{"name": "name", "value": "value"}],
            )


        asyncio.run(main())
        """
        response = await self._raw_client.add_environment_variable(id, request=request, request_options=request_options)
        return response.data

    async def delete_environment_variable(
        self, id: str, name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[FileEnvironmentVariableRequest]:
        """
        Parameters
        ----------
        id : str
            Unique identifier for File.

        name : str
            Name of the Environment Variable to delete.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileEnvironmentVariableRequest]
            Successful Response

        Examples
        --------
        import asyncio

        from humanloop import AsyncHumanloop

        client = AsyncHumanloop(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tools.delete_environment_variable(
                id="id",
                name="name",
            )


        asyncio.run(main())
        """
        response = await self._raw_client.delete_environment_variable(id, name, request_options=request_options)
        return response.data
