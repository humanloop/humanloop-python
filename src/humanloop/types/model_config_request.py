# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .chat_message_with_tool_call import ChatMessageWithToolCall
from .model_config_request_stop import ModelConfigRequestStop
from .model_config_request_tools_item import ModelConfigRequestToolsItem
from .model_endpoints import ModelEndpoints
from .model_providers import ModelProviders
from .response_format import ResponseFormat


class ModelConfigRequest(UncheckedBaseModel):
    """
    Model config used for logging both chat and completion.
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    A friendly display name for the model config. If not provided, a name will be generated.
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    A description of the model config.
    """

    provider: typing.Optional[ModelProviders] = pydantic.Field(default=None)
    """
    The company providing the underlying model service.
    """

    model: str = pydantic.Field()
    """
    The model instance used. E.g. text-davinci-002.
    """

    max_tokens: typing.Optional[int] = pydantic.Field(default=None)
    """
    The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
    """

    temperature: typing.Optional[float] = pydantic.Field(default=None)
    """
    What sampling temperature to use when making a generation. Higher values means the model will be more creative.
    """

    top_p: typing.Optional[float] = pydantic.Field(default=None)
    """
    An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
    """

    stop: typing.Optional[ModelConfigRequestStop] = pydantic.Field(default=None)
    """
    The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.
    """

    presence_penalty: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.
    """

    frequency_penalty: typing.Optional[float] = pydantic.Field(default=None)
    """
    Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.
    """

    other: typing.Optional[typing.Dict[str, typing.Any]] = pydantic.Field(default=None)
    """
    Other parameter values to be passed to the provider call.
    """

    seed: typing.Optional[int] = pydantic.Field(default=None)
    """
    If specified, model will make a best effort to sample deterministically, but it is not guaranteed.
    """

    response_format: typing.Optional[ResponseFormat] = pydantic.Field(default=None)
    """
    The format of the response. Only type json_object is currently supported for chat.
    """

    endpoint: typing.Optional[ModelEndpoints] = pydantic.Field(default=None)
    """
    The provider model endpoint used.
    """

    prompt_template: typing.Optional[str] = pydantic.Field(default=None)
    """
    Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
    """

    chat_template: typing.Optional[typing.List[ChatMessageWithToolCall]] = pydantic.Field(default=None)
    """
    Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. Input variables within the template should be specified with syntax: {{INPUT_NAME}}.
    """

    tools: typing.Optional[typing.List[ModelConfigRequestToolsItem]] = pydantic.Field(default=None)
    """
    Make tools available to OpenAIs chat model as functions.
    """

    type: typing.Optional[typing.Literal["model"]] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
