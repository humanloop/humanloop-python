# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.datetime_utils import serialize_datetime
from ..core.pydantic_utilities import deep_union_pydantic_dicts, pydantic_v1
from ..core.unchecked_base_model import UncheckedBaseModel
from .chat_message import ChatMessage
from .prompt_log_response_tool_choice import PromptLogResponseToolChoice
from .prompt_response import PromptResponse


class PromptLogResponse(UncheckedBaseModel):
    """
    Request for creating a Prompt log.
    """

    id: str = pydantic_v1.Field()
    """
    Unique identifier for the Log.
    """

    output_message: typing.Optional[ChatMessage] = pydantic_v1.Field(default=None)
    """
    The message returned by the provider.
    """

    prompt_tokens: typing.Optional[int] = pydantic_v1.Field(default=None)
    """
    Number of tokens in the prompt used to generate the output.
    """

    output_tokens: typing.Optional[int] = pydantic_v1.Field(default=None)
    """
    Number of tokens in the output generated by the model.
    """

    prompt_cost: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    Cost in dollars associated to the tokens in the prompt.
    """

    output_cost: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    Cost in dollars associated to the tokens in the output.
    """

    finish_reason: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Reason the generation finished.
    """

    prompt: PromptResponse = pydantic_v1.Field()
    """
    Prompt details used to generate the log.
    """

    messages: typing.Optional[typing.List[ChatMessage]] = pydantic_v1.Field(default=None)
    """
    The messages passed to the to provider chat endpoint.
    """

    tool_choice: typing.Optional[PromptLogResponseToolChoice] = pydantic_v1.Field(default=None)
    """
    Controls how the model uses tools. The following options are supported:
    
    - `'none'` means the model will not call any tool and instead generates a message; this is the default when no tools are provided as part of the Prompt.
    - `'auto'` means the model can decide to call one or more of the provided tools; this is the default when tools are provided as part of the Prompt.
    - `'required'` means the model can decide to call one or more of the provided tools.
    - `{'type': 'function', 'function': {name': <TOOL_NAME>}}` forces the model to use the named function.
    """

    output: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Generated output from your model for the provided inputs. Can be `None` if logging an error, or if creating a parent Log with the intention to populate it later.
    """

    raw_output: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Raw output from the provider.
    """

    created_at: typing.Optional[dt.datetime] = pydantic_v1.Field(default=None)
    """
    User defined timestamp for when the log was created.
    """

    error: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Error message if the log is an error.
    """

    provider_latency: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    Duration of the logged event in seconds.
    """

    provider_request: typing.Optional[typing.Dict[str, typing.Any]] = pydantic_v1.Field(default=None)
    """
    Raw request sent to provider.
    """

    provider_response: typing.Optional[typing.Dict[str, typing.Any]] = pydantic_v1.Field(default=None)
    """
    Raw response received the provider.
    """

    session_id: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Unique identifier for the Session to associate the Log to. Allows you to record multiple Logs to a Session (using an ID kept by your internal systems) by passing the same `session_id` in subsequent log requests.
    """

    parent_id: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Unique identifier for the parent Log in a Session. Should only be provided if `session_id` is provided. If provided, the Log will be nested under the parent Log within the Session.
    """

    inputs: typing.Optional[typing.Dict[str, typing.Any]] = pydantic_v1.Field(default=None)
    """
    The inputs passed to the prompt template.
    """

    source: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Identifies where the model was called from.
    """

    metadata: typing.Optional[typing.Dict[str, typing.Any]] = pydantic_v1.Field(default=None)
    """
    Any additional metadata to record.
    """

    save: typing.Optional[bool] = pydantic_v1.Field(default=None)
    """
    Whether the request/response payloads will be stored on Humanloop.
    """

    source_datapoint_id: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    Unique identifier for the Datapoint that this Log is derived from. This can be used by Humanloop to associate Logs to Evaluations. If provided, Humanloop will automatically associate this Log to Evaluations that require a Log for this Datapoint-Version pair.
    """

    batches: typing.Optional[typing.List[str]] = pydantic_v1.Field(default=None)
    """
    Array of Batch Ids that this log is part of. Batches are used to group Logs together for offline Evaluations
    """

    user: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    End-user ID related to the Log.
    """

    environment: typing.Optional[str] = pydantic_v1.Field(default=None)
    """
    The name of the Environment the Log is associated to.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic_v1.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
